''' code generated by ChatGPT 4o
tested on Kattis problem PointInPolygon'''

def is_point_on_segment(p, q, r):
    """
    Check if point q lies on segment pr. Assumes p, q, and r are collinear.
    """
    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1])

def orientation(p, q, r):
    """
    Determine the orientation of the triplet (p, q, r).
    Returns:
    0 -> p, q and r are collinear
    1 -> Clockwise
    2 -> Counterclockwise
    """
    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
    if val == 0:
        return 0  # Collinear
    return 1 if val > 0 else 2  # Clockwise or Counterclockwise

def is_point_on_boundary(polygon, point):
    """
    Check if a point is on the boundary of a polygon.
    """
    n = len(polygon)
    for i in range(n):
        next_i = (i + 1) % n
        p1, p2 = polygon[i], polygon[next_i]
        # Check if the point lies on the current edge of the polygon
        if orientation(p1, point, p2) == 0 and is_point_on_segment(p1, point, p2):
            return True
    return False

def is_point_inside_polygon(polygon, point):
    """
    Determine if the point is inside, outside, or on the boundary of the polygon.

    Args:
    polygon: List of (x, y) tuples representing the vertices of the polygon.
    point: A tuple (x, y) representing the point to check.

    Returns:
    'in', 'out', or 'on'
    """
    # First, check if the point lies on the boundary of the polygon
    if is_point_on_boundary(polygon, point):
        return 'on'

    # Winding number method
    winding_number = 0
    n = len(polygon)

    for i in range(n):
        p1 = polygon[i]
        p2 = polygon[(i + 1) % n]

        if p1[1] <= point[1]:
            if p2[1] > point[1]:  # Upward crossing
                if (p2[0] - p1[0]) * (point[1] - p1[1]) - (point[0] - p1[0]) * (p2[1] - p1[1]) > 0:
                    winding_number += 1
        else:
            if p2[1] <= point[1]:  # Downward crossing
                if (p2[0] - p1[0]) * (point[1] - p1[1]) - (point[0] - p1[0]) * (p2[1] - p1[1]) < 0:
                    winding_number -= 1

    # If winding number is non-zero, point is inside the polygon; otherwise, it's outside.
    return 'in' if winding_number != 0 else 'out'

# example usage
polygon = [(0, 0), (5, 0), (5, 5), (0, 5)]
point = (3, 3)

result = is_point_inside_polygon(polygon, point)
print(f"The point is {result}.")
